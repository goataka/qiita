---
title: Spec KitとGitHub Copilot Coding Agentによる仕様駆動開発の比較
tags:
  - speckit
  - 仕様駆動開発
  - AIエージェント
  - GitHubCopilot
  - ATDD
private: false
updated_at: '2025-12-22T14:32:00+09:00'
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

# はじめに

以前[「雑にエージェントにテスト設計をさせてみて考えたこと」](https://qiita.com/goataka/items/d1f6a3f5acfb23f102d1)で書いた記事の続きです。

仕様駆動や受け入れテスト駆動開発により仕様を明示すれば、エージェントによるテスト設計が可能になるのではないかと考え、現在検証中です。

ただし、結局盛り込もうとしすぎて実装までたどり着けていません。

本記事では、Spec KitとGitHub Copilot Coding Agentを使って仕様駆動開発をした際の比較を行います。

※Kiroはベンダー依存が強いので対象外にしています。

## 前提

- 仕様駆動開発を前提とした比較
- 実際の使用経験を基にした内容
- DDD（ドメイン駆動設計）やATDD（受け入れテスト駆動開発）との相性を重視

## 対象ツール

### GitHub Spec Kit

<https://github.com/github/spec-kit>

- GitHubが提供する仕様駆動開発を支援するCLIツール
- VSCode拡張機能もあり
- 仕様を書きながらコードを生成・更新できる

### GitHub Copilot Coding Agent

https://github.com/features/copilot

- GitHubが提供するAI駆動型のコード生成・編集支援ツール
- 自然言語による指示でコードの生成や修正を行う
- クラウドベースで動作

# 比較表

| 観点 | Spec Kit | GitHub Copilot Coding Agent | 補足 |
|------|---------|------------------------|------|
| **使用形態** | ローカル実行（VSCode拡張） | クラウドベース（Web/デスクトップ/モバイル） | |
| **環境構築** | 必要 | 不要（アカウントのみ） | |
| **マシンリソース** | 依存する | 依存しない | |
| **実行速度** | 高速（ローカル処理） | 中（ネットワーク遅延あり） | |
| **マルチデバイス** | ×（ローカルのみ） | ◎（どこからでも可能） | スマホから指示可能かどうか |
| **仕様の型** | あり（テンプレート） | なし（自由形式） | |
| **型の特徴** | 型が指針になる | 型がないので自由にできる | |
| **学習曲線** | 中（型の理解が必要） | 低（自然言語で指示可能） | |
| **初心者向け** | ◎ | ○ | Spec Kitは仕様駆動に慣れてない人でも進める指針を得られる |
| **柔軟性** | △ | ◎ | |
| **柔軟性の詳細** | 型に制約される | 自由に指示可能 | Spec Kitは仕様の理解や調整に時間を使う |
| **中断・再開** | △ | ◎ | |
| **人間との連携** | △ | ◎ | 途中で辞めたり、人間との連携はしやすい |
| **複数変更同時実行** | △ | ◎ | 複数の変更を同時に指示できる |
| **CI/CD統合** | △ | ◎ | CIネイティブに考えやすい |
| **トラブル対応** | 難（環境依存） | 中（一般的な問題が多い） | Spec Kitは変な動きをした時の対応方法に悩む |
| **コマンド・操作** | コマンドの使い分けが難しい | 特別な仕様はない | |
| **コスト** | ツール費用＋マシンリソース | サブスクリプション費用 | |

## 共通の特徴

### メリット

- 技術的なデファクトの示唆を受けやすい
- ドメイン駆動やATTDとの相性は良い
- 各種仕様が明確なので、テスト駆動開発やドキュメントを作りやすい

### デメリット

- 変更指示の反映に漏れが多い
- 差分をみるのがしんどい
- 色々と考え出して実装まで時間がかかる
- 何をどう纏めるかは工夫が必要
- 変更仕様と確定仕様の棲み分けが必要
- 開発プロセス、機能、アーキテクチャ、リポジトリ管理に分けて考える必要がある
- リリースより後のフェーズ、Ops領域まで書き出すとかなり量が増える
- モノレポか、マルチか悩む
- 提案された仕様の良し悪しは結局確認する必要はある
- 文章量が多くなりがちなので、読むのに疲れる
- 小さい間違いを見落としがち
- 自分でやった方が早いのに無駄に指示してしまう

# プラクティス

## 面倒くさがらずに小さく実装を進める

分かってるがつい増えていく。

理由：
- 変更の追跡が容易
- 問題の早期発見
- 変更漏れの減少

## 導入段階に応じた使い分け

最初はSpec Kitで慣れたら自前がよい気がする。

**最初はSpec Kitで慣れる**
- 仕様駆動開発に初めて取り組む場合、型があるSpec Kitで基本的な流れを学ぶ
- 仕様の書き方、進め方のパターンを体得する

**慣れたらGitHub Copilot Coding Agentへ移行**
- 仕様駆動開発の流れが理解できたら、より柔軟性の高いGitHub Copilot Coding Agentに移行
- プロジェクトに最適な仕様の書き方を確立する

## ハイブリッドアプローチ

状況に応じて使い分ける：

- **初期設計・アーキテクチャ決定**：Spec Kitで構造化して考える
- **機能実装・修正**：GitHub Copilot Coding Agentで柔軟に対応
- **ドキュメント作成**：Spec Kitの型を活用して統一感のある文書を作成
- **複数機能の同時開発**：GitHub Copilot Coding Agentで並行作業

## 仕様管理

### リポジトリ構成

- **小規模プロジェクト**：モノレポで仕様とコードを一元管理
- **大規模プロジェクト**：仕様リポジトリとコードリポジトリを分離して管理

### 仕様の確度

仕様には確度（確定度合い）による性質の違いがある：

- **確定仕様**：プロダクト全体の方針や確定した要件（ストック情報、変更頻度: 低）
- **機能仕様**：各機能の詳細仕様（ストック情報、変更頻度: 中）
- **変更仕様**：開発中の変更内容やPR単位の仕様（フロー情報、変更頻度: 高）

### 情報の種類

仕様を以下の観点で分けて管理する必要がある：

- **開発プロセス**：開発の進め方、ワークフロー
- **機能**：ユーザー向け機能の仕様
- **アーキテクチャ**：システム構造、技術的な設計
- **リポジトリ管理**：ブランチ戦略、コミット規約

### 継続的なメンテナンス

- 実装と仕様の乖離を定期的にチェック
- 仕様の更新を開発プロセスに組み込む
- CI/CDで仕様と実装の整合性を自動チェック

# 推奨

## 初心者・小規模チームにはSpec Kit

以下の場合、Spec Kitから始めることを推奨：

- 仕様駆動開発が初めての場合
- 型があることで安心したい場合
- ローカルでの高速な実行を重視する場合
- チームメンバーが同じ場所で作業している場合

## 経験者・分散チームにはGitHub Copilot Coding Agent

以下の場合、GitHub Copilot Coding Agentが適している：

- 仕様駆動開発の経験がある場合
- リモートワークや移動中も作業したい場合
- プロジェクト固有の仕様形式を作りたい場合
- CI/CDとの統合を重視する場合
- マシンスペックに制約がある場合

## 両方を併用する

理想的には、両方のツールの特性を理解した上で使い分けることです：

1. **学習段階**：Spec Kitで基本を学ぶ
2. **実践段階**：GitHub Copilot Coding Agentで柔軟に開発
3. **標準化段階**：チームに合わせたハイブリッド運用

重要なのは、ツールに依存しすぎないことです。

# おわりに

Spec KitとGitHub Copilot Coding Agent、それぞれに長所と短所がある。

プロジェクトの状況やチームのスキルレベルに応じて選択・使い分けることが重要です。

ツールはあくまで補助であり、最終的な判断は人間が行う必要があります。

いずれかの方法で実装まで完了させたら、また記事を書く予定です。
