---
title: speckitとコーディングエージェントによる仕様駆動開発の比較
tags:
  - speckit
  - 仕様駆動開発
  - AIエージェント
  - コーディングエージェント
  - ATDD
private: false
updated_at: '2025-12-22T13:43:00+09:00'
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

# はじめに

AI技術の発展により、仕様駆動開発（Specification-Driven Development）のアプローチが大きく変わってきています。本記事では、代表的な仕様駆動開発ツールである**speckit**と、GitHub Copilot等の**コーディングエージェント**を使用した仕様駆動開発について、実際の使用経験を基に比較します。

なお、**kiro**は特定ベンダーへの依存が強いため、本記事では対象外としています。

## 仕様駆動開発とは

仕様駆動開発は、コードを書く前に仕様を明確に定義し、その仕様を基に開発を進める手法です。以下のような利点があります：

- **ドキュメントファーストで開発を進められる**：実装前に要件や設計を明確化
- **仕様が実装のガイドとなる**：開発者が何を作るべきか明確に理解できる
- **テスト駆動開発との親和性が高い**：仕様から直接テストケースを作成可能
- **ドメイン駆動設計やATDD（受け入れテスト駆動開発）との相性が良い**：ビジネス要件と実装の乖離を防ぐ

## speckitとは

**speckit**は、仕様駆動開発を支援するローカル実行型のツールです。VSCode拡張機能として提供され、開発者が仕様を書きながらコードを生成・更新できます。

主な特徴：
- **型（テンプレート）が用意されている**：仕様の書き方に一定のフォーマットがある
- **ローカル実行**：開発者のマシン上で動作
- **VSCode統合**：開発環境と統合された使い勝手

## コーディングエージェントとは

**コーディングエージェント**は、GitHub Copilot、Cursor、Windsurf等のAI駆動型のコード生成・編集支援ツールを指します。自然言語による指示でコードの生成や修正を行います。

主な特徴：
- **自由形式の指示**：型やフォーマットに縛られない柔軟な指示が可能
- **クラウドベース**：ローカルマシンのリソースに依存しない
- **マルチデバイス対応**：スマートフォン等からも指示可能

# speckitの特徴

## メリット

### 型があるので初心者でも使いやすい

仕様駆動開発に慣れていない人でも、ある程度の型（テンプレート）が用意されているため、進め方の指針を得られます。「何をどう書けばいいか分からない」という状況を避けられます。

### ローカル実行による高速性

ローカル環境で動作するため、クラウドAPIへの通信待ち時間がなく、アクション実行が高速です。特に頻繁な修正・再実行が必要な場合に有利です。

### 開発環境との親和性

VSCodeで動作するため、通常の開発フローに馴染みやすく、エディタの機能をそのまま活用できます。

## デメリット

### コマンドの使い分けが難しい

複数のコマンドが用意されているため、どのコマンドをどの場面で使うべきか判断が難しい場合があります。

### 仕様の理解や調整に時間がかかる

型があるがゆえに、その型に合わせて仕様を記述する必要があり、仕様の理解や調整に時間を使うことがあります。

### モバイルから利用できない

ローカル環境でしか動作しないため、スマートフォン等からの指示ができません。移動中や外出先での作業には不向きです。

### 環境構築が必要

ローカル環境にツールをインストールし、設定する必要があります。チーム全員が同じ環境を整えるまでに時間がかかることがあります。

### トラブルシューティングが難しい

変な動きをした時に、原因の切り分けや対応方法に悩むことがあります。ローカル環境特有の問題である可能性もあり、解決に時間がかかる場合があります。

# コーディングエージェントの特徴

## メリット

### 自由度の高い指示が可能

型がないため、自由な形式で指示を出すことができます。プロジェクトや状況に応じて柔軟に対応できます。

### 途中中断や人間との連携がしやすい

特別な仕様形式に縛られないため、途中で作業を中断したり、人間が直接コードを修正したりといった連携がスムーズです。

### マルチデバイス対応

スマートフォンやタブレット等、様々なデバイスから指示を出すことができます。移動中でも作業を進められます。

### 複数の変更を同時に指示可能

一度に複数のファイルや機能の変更を指示でき、効率的に開発を進められます。

### マシンパワーに依存しない

クラウドで処理が行われるため、ローカルマシンのスペックに関わらず一定のパフォーマンスを得られます。

### CI/CDとの統合がしやすい

クラウドベースであるため、CI/CD環境との統合を考えやすく、自動化パイプラインに組み込みやすい設計になっています。

## デメリット

### まとめ方の指針がない

型がないため、仕様のまとめ方や構造化について自分で考える必要があります。プロジェクトごとに一貫性を保つための工夫が必要です。

### 変更指示の反映漏れが多い

複数の変更を同時に指示した場合、一部の変更が反映されないことがあります。差分を確認する作業が必要です。

# 共通の特徴

## メリット

### 技術的なデファクトスタンダードの示唆

AI技術により、業界標準やベストプラクティスに沿った実装の提案を受けやすくなります。最新のライブラリやフレームワークの使い方についても学べます。

### ドメイン駆動設計やATTDとの相性が良い

仕様が明確であるため、ドメイン駆動設計（DDD）や受け入れテスト駆動開発（ATDD）とのシナジーが高く、ビジネス要件を直接コードに反映しやすくなります。

### テスト駆動開発やドキュメント作成が容易

各種仕様が明確なため、テストケースやドキュメントを作成しやすくなります。仕様から自動的にテストやドキュメントを生成することも可能です。

## デメリット

### 変更指示の反映漏れ

どちらのツールも、複雑な変更指示の場合、一部の変更が反映されないことがあります。

### 差分確認の負担

生成されたコードの差分を確認する作業が煩雑になりがちです。大量の変更がある場合、レビューに時間がかかります。

### 実装までの時間がかかる

AIが様々な可能性を考慮するため、実際の実装までに時間がかかることがあります。

### 仕様の構造化が必要

何をどう纏めるかについては工夫が必要です。特に以下の観点で考える必要があります：

- **変更仕様と確定仕様の棲み分け**：開発中の仕様と確定した仕様の管理
- **開発プロセス、機能、アーキテクチャ、リポジトリ管理**：各観点で分けて考える必要がある
- **リリース後のフェーズ**：運用（Ops）領域まで記述すると文書量が大幅に増加
- **モノレポかマルチレポか**：仕様管理の粒度とリポジトリ構成の検討

### 仕様の品質管理が必要

提案された仕様の良し悪しは、結局人間が確認する必要があります。AI任せにはできません。

### ドキュメント量の増加

仕様を詳細に書くと文章量が多くなりがちで、読むのに疲れてしまいます。

### 小さい間違いの見落とし

大量の文章やコードの中で、小さな間違いを見落としがちになります。

### 効率性のジレンマ

自分で直接実装した方が早いケースでも、つい指示ベースで進めてしまい、かえって時間がかかることがあります。

# 比較表

以下の表は、speckitとコーディングエージェントの主要な違いを整理したものです。

| 観点 | speckit | コーディングエージェント |
|------|---------|------------------------|
| **使用形態** | ローカル実行（VSCode拡張） | クラウドベース（Web/デスクトップ/モバイル） |
| **仕様の型** | テンプレート・型あり | 自由形式 |
| **学習曲線** | 中（型の理解が必要） | 低（自然言語で指示可能） |
| **実行速度** | 高速（ローカル処理） | 中（ネットワーク遅延あり） |
| **初心者向け** | ◎（型が指針になる） | ○（自由度が高い分迷いも） |
| **柔軟性** | △（型に制約される） | ◎（自由に指示可能） |
| **環境構築** | 必要 | 不要（アカウントのみ） |
| **マシンリソース** | 依存する | 依存しない |
| **マルチデバイス** | ×（ローカルのみ） | ◎（どこからでも可能） |
| **複数変更同時実行** | △ | ◎ |
| **中断・再開** | △ | ◎ |
| **人間との連携** | △ | ◎ |
| **CI/CD統合** | △ | ◎ |
| **トラブル対応** | 難（環境依存） | 中（一般的な問題が多い） |
| **コスト** | ツール費用＋マシンリソース | サブスクリプション費用 |

# プラクティス（実践的なアドバイス）

## 面倒くさがらずに小さく実装を進める

どちらのツールを使う場合も、一度に大きな変更を指示するのではなく、小さい単位で実装を進めた方が良い結果が得られます。

理由：
- **変更の追跡が容易**：小さい変更であれば差分レビューが楽
- **問題の早期発見**：エラーが出た時に原因を特定しやすい
- **変更漏れの減少**：指示が単純な分、反映漏れが減る

ただし、実際には「分かってるがつい増えていく」のが現実です。意識的に小さく分割する習慣をつけることが重要です。

## 導入段階に応じた使い分け

**最初はspeckitで慣れる**
- 仕様駆動開発に初めて取り組む場合、型があるspeckitで基本的な流れを学ぶ
- 仕様の書き方、進め方のパターンを体得する

**慣れたら自前（コーディングエージェント）へ移行**
- 仕様駆動開発の流れが理解できたら、より柔軟性の高いコーディングエージェントに移行
- プロジェクトに最適な仕様の書き方を確立する

## ハイブリッドアプローチ

状況に応じて使い分けることも有効です：

- **初期設計・アーキテクチャ決定**：speckitで構造化して考える
- **機能実装・修正**：コーディングエージェントで柔軟に対応
- **ドキュメント作成**：speckitの型を活用して統一感のある文書を作成
- **複数機能の同時開発**：コーディングエージェントで並行作業

## 仕様管理のベストプラクティス

### リポジトリ構成

- **小規模プロジェクト**：モノレポで仕様とコードを一元管理
- **大規模プロジェクト**：仕様リポジトリとコードリポジトリを分離して管理

### 仕様の粒度

- **確定仕様**：プロダクト全体の方針や確定した要件（変更頻度: 低）
- **機能仕様**：各機能の詳細仕様（変更頻度: 中）
- **変更仕様**：開発中の変更内容やPR単位の仕様（変更頻度: 高）

### 継続的なメンテナンス

- 実装と仕様の乖離を定期的にチェック
- 仕様の更新を開発プロセスに組み込む
- CI/CDで仕様と実装の整合性を自動チェック

# 推奨（まとめ）

## 初心者・小規模チームには speckit

以下の場合、speckitから始めることを推奨します：

- **仕様駆動開発が初めて**の場合
- **型があることで安心したい**場合
- **ローカルでの高速な実行を重視**する場合
- **チームメンバーが同じ場所で作業**している場合

## 経験者・分散チームには コーディングエージェント

以下の場合、コーディングエージェントが適しています：

- **仕様駆動開発の経験がある**場合
- **リモートワークや移動中も作業したい**場合
- **プロジェクト固有の仕様形式を作りたい**場合
- **CI/CDとの統合を重視**する場合
- **マシンスペックに制約がある**場合

## 両方を併用する

理想的には、**両方のツールの特性を理解した上で使い分ける**ことです：

1. **学習段階**：speckitで基本を学ぶ
2. **実践段階**：コーディングエージェントで柔軟に開発
3. **標準化段階**：チームに合わせたハイブリッド運用

重要なのは、**ツールに依存しすぎない**ことです。ツールは手段であり、目的ではありません。仕様駆動開発の本質である「仕様を明確にしてから実装する」という原則を忘れずに、ツールを活用しましょう。

# おわりに

speckitとコーディングエージェント、それぞれに長所と短所があります。どちらが優れているというわけではなく、**プロジェクトの状況やチームのスキルレベルに応じて選択・使い分けることが重要**です。

仕様駆動開発は、AIツールの登場により大きく進化しています。これらのツールを効果的に活用することで、より高品質なソフトウェアを効率的に開発できるようになります。

ただし、ツールはあくまで補助であり、**最終的な判断は人間が行う必要があります**。AIの提案を鵜呑みにせず、批判的に検討し、プロジェクトに最適な形に調整していくことが、成功への鍵となります。

今後も、AI技術の発展とともに仕様駆動開発のツールやプラクティスは進化していくでしょう。常に最新の情報をキャッチアップしながら、自分たちのプロジェクトに最適な開発手法を見つけていきましょう。
